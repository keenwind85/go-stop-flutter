# 고스톱 모드 추가계획 설계 문서

## 1. 개요

### 1.1 목표
기존 2인용 "맞고" 게임에 3인용 "고스톱" 모드를 추가하여, 방 생성 시 게임 모드를 선택할 수 있도록 한다.

### 1.2 주요 차이점 (맞고 vs 고스톱)

| 항목 | 맞고 (2인) | 고스톱 (3인) |
|------|-----------|-------------|
| 플레이어 수 | 2명 | 3명 |
| 손패 | 10장 | 7장 |
| 바닥패 | 8장 | 6장 |
| 승리 점수 | 7점 | 3점 |
| 피박 기준 | 7장 이하 | 5장 이하 |
| 게임 시작 조건 | 2명 입장 | 3명 입장 |

---

## 2. 현재 프로젝트 구조 분석

### 2.1 핵심 모델 (`lib/models/`)

#### `game_room.dart`
```dart
// 현재 구조 - 2인 기준
class GameRoom {
  final String hostUid;
  final String hostName;
  final String? guestUid;    // 단일 게스트
  final String? guestName;
  // ...
}

class GameState {
  final List<CardData> hostHand;   // 호스트 손패
  final List<CardData> guestHand;  // 게스트 손패 (단일)
  final CapturedCards hostCaptured;
  final CapturedCards guestCaptured;
  // ...
}
```

### 2.2 게임 로직 (`lib/services/`)

#### `matgo_logic_service.dart` (1973줄)
- `initializeGame()`: 게임 초기화, 덱 생성 및 배분
- `determineFirstTurn()`: 선 결정 로직
- `playCard()`: 카드 플레이 처리
- `checkGameEndOnExhaustion()`: 게임 종료 조건 체크
- 현재 `GameConstants.goStopThreshold = 7` 고정

#### `room_service.dart`
- `createRoom()`: 방 생성 (호스트 정보만)
- `joinRoom()`: 방 입장 (단일 게스트)
- `startGame()`: 게임 시작 (2인 기준)

#### `deck_generator.dart`
```dart
// 현재 상수
static const int cardsPerPlayer = 10;  // 맞고 기준
static const int fieldCardCount = 8;   // 맞고 기준
```

### 2.3 UI 컴포넌트 (`lib/ui/`)

#### `opponent_zone.dart`
- 단일 상대방 영역 (화면 상단)
- 아바타, 획득패, 점수, 턴 표시

#### `player_zone.dart`
- 나의 영역 (화면 하단)
- 손패, 획득패, 점수

---

## 3. 설계 계획

### 3.1 데이터 모델 변경

#### 3.1.1 GameMode 열거형 추가
```dart
/// 게임 모드
enum GameMode {
  matgo,    // 맞고 (2인)
  gostop,   // 고스톱 (3인)
}

extension GameModeExtension on GameMode {
  String get displayName {
    switch (this) {
      case GameMode.matgo:
        return '맞고';
      case GameMode.gostop:
        return '고스톱';
    }
  }

  int get playerCount {
    switch (this) {
      case GameMode.matgo:
        return 2;
      case GameMode.gostop:
        return 3;
    }
  }

  int get cardsPerPlayer {
    switch (this) {
      case GameMode.matgo:
        return 10;
      case GameMode.gostop:
        return 7;
    }
  }

  int get fieldCardCount {
    switch (this) {
      case GameMode.matgo:
        return 8;
      case GameMode.gostop:
        return 6;
    }
  }

  int get winThreshold {
    switch (this) {
      case GameMode.matgo:
        return 7;
      case GameMode.gostop:
        return 3;
    }
  }

  int get piBakThreshold {
    switch (this) {
      case GameMode.matgo:
        return 7;
      case GameMode.gostop:
        return 5;
    }
  }
}
```

#### 3.1.2 GameRoom 모델 확장
```dart
class GameRoom {
  final String id;
  final String hostUid;
  final String hostName;
  final GameMode gameMode;           // 새로 추가

  // 게스트 정보 확장 (3인 지원)
  final String? guest1Uid;           // 기존 guestUid → guest1Uid
  final String? guest1Name;
  final String? guest2Uid;           // 새로 추가 (고스톱용)
  final String? guest2Name;

  final RoomState state;
  final DateTime createdAt;
  // ...

  /// 현재 입장한 플레이어 수
  int get currentPlayerCount {
    int count = 1; // 호스트
    if (guest1Uid != null) count++;
    if (guest2Uid != null) count++;
    return count;
  }

  /// 게임 시작 가능 여부
  bool get canStartGame => currentPlayerCount >= gameMode.playerCount;
}
```

#### 3.1.3 GameState 모델 확장
```dart
class GameState {
  // 플레이어별 손패 (Map으로 변경하여 확장성 확보)
  final Map<String, List<CardData>> playerHands;

  // 플레이어별 획득패
  final Map<String, CapturedCards> playerCaptured;

  // 플레이어별 점수
  final Map<String, ScoreInfo> playerScores;

  // 턴 순서 (uid 리스트)
  final List<String> turnOrder;

  // 현재 턴 인덱스
  final int currentTurnIndex;

  // 바닥패
  final List<CardData> fieldCards;

  // 덱
  final List<CardData> deck;

  // 게임 모드
  final GameMode gameMode;

  // ...

  /// 현재 턴 플레이어 UID
  String get currentTurnUid => turnOrder[currentTurnIndex];

  /// 다음 턴으로 이동
  int get nextTurnIndex => (currentTurnIndex + 1) % turnOrder.length;
}
```

#### 3.1.4 PlayerInfo 확장
```dart
class PlayerInfo {
  final String uid;
  final String name;
  final int playerIndex;    // 0: 호스트, 1: 게스트1, 2: 게스트2
  final int? coinBalance;
  final String? avatarType; // 'host', 'guest1', 'guest2'

  // ...
}
```

### 3.2 서비스 계층 변경

#### 3.2.1 RoomService 확장

```dart
class RoomService {
  /// 방 생성 (모드 선택 추가)
  Future<String> createRoom({
    required String hostUid,
    required String hostName,
    required GameMode gameMode,  // 새로 추가
    int? betAmount,
  }) async {
    // ...
    final roomData = {
      'hostUid': hostUid,
      'hostName': hostName,
      'gameMode': gameMode.name,  // 'matgo' or 'gostop'
      'state': 'waiting',
      'createdAt': ServerValue.timestamp,
      // ...
    };
    // ...
  }

  /// 방 입장 (3인 지원)
  Future<void> joinRoom({
    required String roomId,
    required String guestUid,
    required String guestName,
  }) async {
    // 트랜잭션으로 처리
    await _db.child('rooms/$roomId').runTransaction((data) {
      if (data == null) return Transaction.abort();

      final room = Map<String, dynamic>.from(data as Map);
      final gameMode = GameMode.values.byName(room['gameMode'] ?? 'matgo');

      // 맞고: guest1만 필요
      // 고스톱: guest1, guest2 모두 필요
      if (room['guest1Uid'] == null) {
        room['guest1Uid'] = guestUid;
        room['guest1Name'] = guestName;
      } else if (gameMode == GameMode.gostop && room['guest2Uid'] == null) {
        room['guest2Uid'] = guestUid;
        room['guest2Name'] = guestName;
      } else {
        return Transaction.abort(); // 방이 꽉 참
      }

      // 게임 시작 조건 충족 시 상태 변경
      final playerCount = 1 +
        (room['guest1Uid'] != null ? 1 : 0) +
        (room['guest2Uid'] != null ? 1 : 0);

      if (playerCount >= gameMode.playerCount) {
        room['state'] = 'ready';
      }

      return Transaction.success(room);
    });
  }
}
```

#### 3.2.2 MatgoLogicService 확장

```dart
class MatgoLogicService {
  /// 게임 초기화 (모드별 분기)
  Future<void> initializeGame(String roomId) async {
    final room = await _getRoom(roomId);
    final gameMode = room.gameMode;

    // 모드별 상수 적용
    final cardsPerPlayer = gameMode.cardsPerPlayer;
    final fieldCardCount = gameMode.fieldCardCount;

    // 플레이어 목록 구성
    final players = [room.hostUid];
    if (room.guest1Uid != null) players.add(room.guest1Uid!);
    if (room.guest2Uid != null) players.add(room.guest2Uid!);

    // 덱 생성 및 배분
    final deck = DeckGenerator.createDeck();
    final shuffled = DeckGenerator.shuffle(deck);

    final playerHands = <String, List<CardData>>{};
    final playerCaptured = <String, CapturedCards>{};

    int cardIndex = 0;
    for (final uid in players) {
      playerHands[uid] = shuffled.sublist(cardIndex, cardIndex + cardsPerPlayer);
      cardIndex += cardsPerPlayer;
      playerCaptured[uid] = CapturedCards.empty();
    }

    final fieldCards = shuffled.sublist(cardIndex, cardIndex + fieldCardCount);
    final remainingDeck = shuffled.sublist(cardIndex + fieldCardCount);

    // 선 결정
    final turnOrder = _determineFirstTurn(players, playerHands);

    // GameState 생성 및 저장
    // ...
  }

  /// 선 결정 (3인 확장)
  List<String> _determineFirstTurn(
    List<String> players,
    Map<String, List<CardData>> hands,
  ) {
    // 기존 로직: 1월 카드 보유자 또는 랜덤
    // 선 결정 후 나머지 순서는 시계방향 (랜덤 배치)

    String? firstPlayer;
    for (final uid in players) {
      final hasJanuaryCard = hands[uid]!.any((card) => card.month == 1);
      if (hasJanuaryCard) {
        firstPlayer = uid;
        break;
      }
    }

    firstPlayer ??= players[Random().nextInt(players.length)];

    // 선을 제외한 나머지 플레이어 순서 랜덤화
    final others = players.where((p) => p != firstPlayer).toList()..shuffle();
    return [firstPlayer, ...others];
  }

  /// 점수 체크 (모드별 승리 조건)
  bool _checkWinCondition(GameState state, String uid) {
    final score = state.playerScores[uid]?.totalScore ?? 0;
    return score >= state.gameMode.winThreshold;
  }

  /// 피박 체크 (모드별 기준)
  bool _checkPiBak(GameState state, String uid) {
    final piCount = state.playerCaptured[uid]?.piCount ?? 0;
    return piCount <= state.gameMode.piBakThreshold;
  }
}
```

#### 3.2.3 DeckGenerator 수정

```dart
class DeckGenerator {
  /// 모드별 카드 배분
  static DealResult dealCards(GameMode mode, List<String> playerUids) {
    final deck = createDeck();
    final shuffled = shuffle(deck);

    final cardsPerPlayer = mode.cardsPerPlayer;
    final fieldCardCount = mode.fieldCardCount;

    final playerHands = <String, List<CardData>>{};
    int index = 0;

    for (final uid in playerUids) {
      playerHands[uid] = shuffled.sublist(index, index + cardsPerPlayer);
      index += cardsPerPlayer;
    }

    final fieldCards = shuffled.sublist(index, index + fieldCardCount);
    final remainingDeck = shuffled.sublist(index + fieldCardCount);

    return DealResult(
      playerHands: playerHands,
      fieldCards: fieldCards,
      deck: remainingDeck,
    );
  }
}

class DealResult {
  final Map<String, List<CardData>> playerHands;
  final List<CardData> fieldCards;
  final List<CardData> deck;

  DealResult({
    required this.playerHands,
    required this.fieldCards,
    required this.deck,
  });
}
```

### 3.3 UI 계층 변경

#### 3.3.1 방 생성 다이얼로그 수정

```dart
class CreateRoomDialog extends ConsumerStatefulWidget {
  // ...
}

class _CreateRoomDialogState extends ConsumerState<CreateRoomDialog> {
  GameMode _selectedMode = GameMode.matgo;  // 기본값: 맞고

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Column(
        children: [
          // 게임 모드 선택
          _buildModeSelector(),

          // 판돈 설정 (기존)
          _buildBetAmountSelector(),

          // 생성 버튼
          _buildCreateButton(),
        ],
      ),
    );
  }

  Widget _buildModeSelector() {
    return Row(
      children: [
        _buildModeOption(GameMode.matgo, '맞고 (2인)'),
        _buildModeOption(GameMode.gostop, '고스톱 (3인)'),
      ],
    );
  }

  Widget _buildModeOption(GameMode mode, String label) {
    final isSelected = _selectedMode == mode;
    return GestureDetector(
      onTap: () => setState(() => _selectedMode = mode),
      child: Container(
        padding: EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: isSelected ? AppColors.accent : Colors.transparent,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: isSelected ? AppColors.accent : AppColors.woodLight,
          ),
        ),
        child: Text(label),
      ),
    );
  }
}
```

#### 3.3.2 방 목록 아이템 수정 (모드 표시)

```dart
class RoomListItem extends StatelessWidget {
  final GameRoom room;

  @override
  Widget build(BuildContext context) {
    return Container(
      child: Row(
        children: [
          // 게임 모드 태그
          _buildModeTag(),

          // 방 정보
          _buildRoomInfo(),

          // 플레이어 현황
          _buildPlayerCount(),
        ],
      ),
    );
  }

  Widget _buildModeTag() {
    final isGostop = room.gameMode == GameMode.gostop;
    return Container(
      padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: isGostop ? Colors.orange : Colors.blue,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        room.gameMode.displayName,
        style: TextStyle(color: Colors.white, fontSize: 12),
      ),
    );
  }

  Widget _buildPlayerCount() {
    return Text(
      '${room.currentPlayerCount}/${room.gameMode.playerCount}',
      style: TextStyle(color: AppColors.textSecondary),
    );
  }
}
```

#### 3.3.3 게임 화면 UI 분기

```dart
class GameScreenNew extends ConsumerStatefulWidget {
  // ...
}

class _GameScreenNewState extends ConsumerState<GameScreenNew> {
  @override
  Widget build(BuildContext context) {
    final gameMode = room?.gameMode ?? GameMode.matgo;

    return Scaffold(
      body: Column(
        children: [
          // 상대방 영역 (모드별 분기)
          if (gameMode == GameMode.matgo)
            OpponentZone(/* 기존 단일 상대 */)
          else
            GostopOpponentZone(/* 2명의 상대 */),

          // 바닥패 영역 (공통)
          FieldZone(/* ... */),

          // 나의 영역 (공통)
          PlayerZone(/* ... */),
        ],
      ),
    );
  }
}
```

#### 3.3.4 고스톱 상대 영역 (신규)

```dart
/// 고스톱 모드용 상대방 영역 (2명 표시)
class GostopOpponentZone extends StatelessWidget {
  final PlayerInfo? opponent1;
  final PlayerInfo? opponent2;
  final CapturedCards? captured1;
  final CapturedCards? captured2;
  final int score1;
  final int score2;
  final bool isOpponent1Turn;
  final bool isOpponent2Turn;
  // ...

  @override
  Widget build(BuildContext context) {
    return Container(
      child: Row(
        children: [
          // 왼쪽 상대 (Guest-1)
          Expanded(
            child: _buildOpponentSection(
              opponent: opponent1,
              captured: captured1,
              score: score1,
              isTurn: isOpponent1Turn,
              avatarType: 'guest1',
            ),
          ),

          // 구분선
          Container(width: 2, color: AppColors.woodLight),

          // 오른쪽 상대 (Guest-2)
          Expanded(
            child: _buildOpponentSection(
              opponent: opponent2,
              captured: captured2,
              score: score2,
              isTurn: isOpponent2Turn,
              avatarType: 'guest2',
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildOpponentSection({
    required PlayerInfo? opponent,
    required CapturedCards? captured,
    required int score,
    required bool isTurn,
    required String avatarType,
  }) {
    return Column(
      children: [
        // 아바타 + 닉네임
        Row(
          children: [
            GameAvatar(avatarType: avatarType, state: /* ... */),
            Text(opponent?.name ?? '대기중'),
          ],
        ),
        // 획득패
        _buildCapturedCards(captured),
        // 점수
        Text('$score점'),
      ],
    );
  }
}
```

#### 3.3.5 아이템 타겟 선택 팝업 (신규)

```dart
/// 아이템 사용 시 대상 선택 팝업 (고스톱 모드)
class ItemTargetDialog extends StatelessWidget {
  final String itemName;
  final List<PlayerInfo> opponents;
  final Function(String targetUid) onSelect;

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text('$itemName 대상 선택'),
          SizedBox(height: 16),

          ...opponents.map((opponent) => ListTile(
            leading: GameAvatar(
              avatarType: opponent.avatarType,
              size: 40,
            ),
            title: Text(opponent.name),
            onTap: () {
              onSelect(opponent.uid);
              Navigator.pop(context);
            },
          )),

          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('취소'),
          ),
        ],
      ),
    );
  }
}
```

**대상 선택이 필요한 아이템:**
- "제발 Go만해!" - 특정 상대에게 적용
- "제발 Stop만해!" - 특정 상대에게 적용
- "우리 패 바꾸자!" - 특정 상대와 손패 교환

### 3.4 아바타 시스템 확장

#### 3.4.1 필요한 새 아바타 이미지

```
assets/avatar/
├── host/
│   ├── normal.png (기존)
│   ├── 4turn.png (기존)
│   ├── lose.png (기존)
│   ├── win.png (기존)
│   └── mad.png (기존)
├── guest1/             # 기존 guest → guest1로 rename
│   ├── normal.png
│   ├── 4turn.png
│   ├── lose.png
│   ├── win.png
│   └── mad.png
└── guest2/             # 신규 추가
    ├── normal.png
    ├── 4turn.png
    ├── lose.png
    ├── win.png
    └── mad.png
```

#### 3.4.2 GameAvatar 위젯 수정

```dart
class GameAvatar extends StatelessWidget {
  final String avatarType;  // 'host', 'guest1', 'guest2'
  final AvatarState state;
  final double size;

  String get _imagePath {
    final stateName = state.name; // normal, 4turn, lose, win, mad
    return 'assets/avatar/$avatarType/$stateName.png';
  }

  @override
  Widget build(BuildContext context) {
    return Image.asset(
      _imagePath,
      width: size,
      height: size,
      errorBuilder: (_, __, ___) => _buildFallback(),
    );
  }
}
```

### 3.5 Firebase 데이터베이스 규칙 수정

```json
{
  "rules": {
    "rooms": {
      "$roomId": {
        ".read": "auth != null",
        ".write": "auth != null",

        "gameMode": {
          ".validate": "newData.val() == 'matgo' || newData.val() == 'gostop'"
        },

        "guest1Uid": {
          ".validate": "newData.isString()"
        },
        "guest1Name": {
          ".validate": "newData.isString()"
        },
        "guest2Uid": {
          ".validate": "newData.isString()"
        },
        "guest2Name": {
          ".validate": "newData.isString()"
        }
      }
    }
  }
}
```

---

## 4. 추가 고려사항 (사용자 미언급)

### 4.1 게임 종료 처리

#### 4.1.1 3인 게임 승리자 결정
- **단독 승리**: 한 명이 3점 이상 달성 → 해당 플레이어 승리
- **동시 도달**: 같은 턴에 여러 명이 3점 이상 → 점수 높은 사람 승리
- **동점 처리**: 점수 동일 시 선 플레이어 우선

#### 4.1.2 나가리 (무승부) 처리
- 덱 소진 시 아무도 3점 미달성 → 나가리
- 3인 모두 동점으로 종료 → 나가리

### 4.2 코인 정산 로직

#### 4.2.1 3인 정산 공식
```dart
/// 고스톱 정산 (3인)
/// 승자는 패자 2명에게서 각각 코인을 받음
void settleGostop(GameResult result) {
  final winner = result.winner;
  final losers = result.players.where((p) => p != winner).toList();

  for (final loser in losers) {
    final baseAmount = calculateBaseAmount(winner, loser);
    final multiplier = calculateMultiplier(result); // 피박, 광박 등
    final amount = baseAmount * multiplier;

    // winner에게 amount 추가
    // loser에게서 amount 차감
  }
}
```

#### 4.2.2 배수 적용
- 피박 (5장 이하): 2배
- 광박 (광 0장): 2배
- 고 보너스: 고 횟수만큼 추가 점수

### 4.3 중도 퇴장 처리

#### 4.3.1 대기 중 퇴장
- 게스트 퇴장: 해당 슬롯 비움, 다른 유저 입장 가능
- 호스트 퇴장: 방 삭제 또는 게스트1에게 호스트 권한 이전

#### 4.3.2 게임 중 퇴장 (기권 처리)
- 퇴장자 자동 패배 처리
- 남은 2명이 게임 계속 OR 게임 종료
- 권장: 남은 2명도 게임 종료, 퇴장자만 패배 코인 차감

```dart
enum LeaveReason {
  voluntary,    // 자발적 퇴장
  disconnected, // 연결 끊김
  timeout,      // 시간 초과
}

Future<void> handlePlayerLeave(String roomId, String uid, LeaveReason reason) async {
  // 게임 중이면 기권 처리
  // 대기 중이면 슬롯 비움
}
```

### 4.4 턴 타임아웃 처리

#### 4.4.1 3인 턴 타임아웃
- 현재: 30초 타임아웃 시 자동 카드 선택
- 고스톱: 동일하게 적용, 3연속 타임아웃 시 자동 기권

### 4.5 재대결 로직 수정

#### 4.5.1 3인 재대결 투표
```dart
/// 3인 재대결: 3명 모두 동의해야 재대결
class RematchVote {
  final Map<String, bool> votes; // uid -> agreed

  bool get allAgreed => votes.values.every((v) => v == true);
  int get agreedCount => votes.values.where((v) => v == true).length;
}
```

### 4.6 특수 조합 (족보) 확인

#### 4.6.1 초기 패 확인 (총통)
- 3인 고스톱에서도 총통 적용
- 7장 중 같은 월 4장 → 총통 선언 가능

#### 4.6.2 흔들기 조건
- 바닥에 같은 월 3장 + 손에 1장 → 흔들기 가능
- 3인에서도 동일 적용

### 4.7 관전 기능 (선택적)

#### 4.7.1 고스톱 관전
- 3인 게임은 관전자 허용 가능
- 관전자용 뷰: 모든 플레이어 획득패만 표시, 손패 비공개

---

## 5. 구현 우선순위

### Phase 1: 데이터 모델 (1주차)
1. GameMode 열거형 추가
2. GameRoom 모델 확장 (guest2 추가)
3. GameState 모델 확장 (Map 기반)
4. Firebase 규칙 업데이트

### Phase 2: 방 관리 (1주차)
1. RoomService 수정 (모드 선택, 3인 입장)
2. 방 생성 다이얼로그 수정
3. 방 목록 UI 수정 (모드 태그)
4. 로비 필터링 (모드별)

### Phase 3: 게임 로직 (2주차)
1. DeckGenerator 수정 (모드별 배분)
2. MatgoLogicService 확장 (3인 턴 순환)
3. 승리/정산 로직 수정
4. 피박/광박 기준 수정

### Phase 4: UI 구현 (2주차)
1. GostopOpponentZone 컴포넌트 생성
2. 게임 화면 모드별 분기
3. 아이템 타겟 선택 팝업
4. Guest-2 아바타 이미지 추가

### Phase 5: 테스트 및 보완 (1주차)
1. 3인 게임 플로우 테스트
2. 중도 퇴장 시나리오 테스트
3. 정산 로직 검증
4. UI/UX 보완

---

## 6. 파일 변경 목록

### 6.1 수정 필요 파일

| 파일 | 변경 내용 |
|------|----------|
| `lib/models/game_room.dart` | GameMode 추가, guest2 필드, 3인 지원 |
| `lib/services/room_service.dart` | 모드별 방 생성/입장 로직 |
| `lib/services/matgo_logic_service.dart` | 3인 턴 순환, 모드별 상수 적용 |
| `lib/game/systems/deck_generator.dart` | 모드별 카드 배분 |
| `lib/ui/screens/lobby_screen.dart` | 방 목록 모드 표시, 필터 |
| `lib/ui/widgets/create_room_dialog.dart` | 모드 선택 UI |
| `lib/ui/game/game_screen_new.dart` | 모드별 UI 분기 |
| `lib/ui/game/widgets/opponent_zone.dart` | 기존 유지 (맞고용) |
| `lib/ui/game/widgets/game_avatar.dart` | avatarType 확장 |
| `lib/config/constants.dart` | GameMode별 상수 |
| `database.rules.json` | guest2, gameMode 규칙 |

### 6.2 신규 생성 파일

| 파일 | 설명 |
|------|------|
| `lib/ui/game/widgets/gostop_opponent_zone.dart` | 고스톱 2인 상대 영역 |
| `lib/ui/widgets/item_target_dialog.dart` | 아이템 대상 선택 팝업 |
| `assets/avatar/guest2/*.png` | Guest-2 아바타 이미지 5종 |

---

## 7. 예상 리스크 및 대응

| 리스크 | 영향도 | 대응 방안 |
|--------|--------|----------|
| 기존 맞고 게임 회귀 버그 | 높음 | 맞고 모드 철저한 회귀 테스트 |
| 3인 동시 접속 동기화 이슈 | 중간 | Firebase 트랜잭션 활용 강화 |
| UI 레이아웃 깨짐 (3인 표시) | 중간 | 반응형 디자인, 다양한 화면 테스트 |
| 정산 로직 오류 | 높음 | 단위 테스트 작성, 시뮬레이션 |
| Guest-2 아바타 미준비 | 낮음 | 기본 아바타 fallback 처리 |

---

## 8. 결론

이 설계 문서는 기존 2인용 맞고 게임에 3인용 고스톱 모드를 추가하기 위한 전체적인 구조와 구현 계획을 담고 있습니다.

핵심 변경사항:
1. **GameMode 도입**: 맞고/고스톱 모드 분리
2. **3인 플레이어 지원**: 데이터 모델 확장
3. **모드별 게임 규칙**: 손패, 바닥패, 승리 조건 차별화
4. **UI 분기**: 상대 영역 2분할 (고스톱)
5. **아이템 타겟팅**: 3인 모드 대상 선택 팝업

구현 시 기존 맞고 모드의 안정성을 유지하면서 점진적으로 고스톱 기능을 추가하는 것을 권장합니다.
